@page "/"
@using MathComicGenerator.Shared.Models
@using MathComicGenerator.Web.Components
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager

<PageTitle>数学漫画生成器</PageTitle>

<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="text-center mb-4">
                <h1 class="display-4 text-primary">
                    <i class="fas fa-magic me-3"></i>
                    数学漫画生成器
                </h1>
                <p class="lead text-muted">让数学学习变得生动有趣</p>
            </div>
        </div>
    </div>

    <div class="row">
        @if (currentStep == GenerationStep.Input)
        {
            <!-- 输入区域 -->
            <div class="col-lg-4 mb-4">
                <MathInputComponent OnSubmit="HandlePromptGeneration" IsGenerating="isGeneratingPrompt" />
            </div>

            <!-- 漫画显示区域 -->
            <div class="col-lg-8 mb-4">
                <ComicDisplayComponent Comic="currentComic" 
                                     IsLoading="isGeneratingComic"
                                     OnSave="HandleSaveComic"
                                     OnShare="HandleShareComic"
                                     OnExport="HandleExportComic" />
            </div>
        }
        else if (currentStep == GenerationStep.PromptEdit)
        {
            <!-- 提示词编辑区域 -->
            <div class="col-lg-6 mb-4">
                <PromptEditorComponent PromptResponse="currentPromptResponse"
                                     IsGenerating="isGeneratingComic"
                                     OnGenerateComic="HandleComicGeneration"
                                     OnGoBack="HandleGoBackToInput" />
            </div>

            <!-- 漫画显示区域 -->
            <div class="col-lg-6 mb-4">
                <ComicDisplayComponent Comic="currentComic" 
                                     IsLoading="isGeneratingComic"
                                     OnSave="HandleSaveComic"
                                     OnShare="HandleShareComic"
                                     OnExport="HandleExportComic" />
            </div>
        }
    </div>

    <div class="row">
        <!-- 历史记录区域 -->
        <div class="col-12">
            <HistoryComponent ComicHistory="comicHistory"
                            IsLoading="isLoadingHistory"
                            OnRefresh="LoadComicHistory"
                            OnView="HandleViewComic"
                            OnShare="HandleShareComic"
                            OnDelete="HandleDeleteComic" />
        </div>
    </div>
</div>

<!-- 通知Toast -->
<div class="toast-container position-fixed bottom-0 end-0 p-3">
    <div id="notificationToast" class="toast" role="alert">
        <div class="toast-header">
            <i class="fas fa-info-circle text-primary me-2"></i>
            <strong class="me-auto">通知</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast"></button>
        </div>
        <div class="toast-body">
            @notificationMessage
        </div>
    </div>
</div>

@code {
    private MultiPanelComic? currentComic;
    private PromptGenerationResponse? currentPromptResponse;
    private List<ComicMetadata> comicHistory = new();
    private GenerationStep currentStep = GenerationStep.Input;
    private bool isGeneratingPrompt = false;
    private bool isGeneratingComic = false;
    private bool isLoadingHistory = false;
    private string notificationMessage = string.Empty;

    public enum GenerationStep
    {
        Input,
        PromptEdit
    }

    protected override Task OnInitializedAsync()
    {
        // Log component initialization
        _ = Task.Run(async () =>
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("logInfo", "Index component initializing", new { 
                    component = "Index",
                    step = currentStep.ToString(),
                    timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")
                }, "COMPONENT_INIT");
            }
            catch (InvalidOperationException)
            {
                // Ignore JS interop errors during prerendering
            }
        });
        
        return Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("logInfo", "Index component first render completed", new { 
                    component = "Index",
                    firstRender = true,
                    timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")
                }, "COMPONENT_RENDER");
                
                await LoadComicHistory();
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("logError", "Error in OnAfterRenderAsync", ex.Message, "COMPONENT_ERROR");
            }
        }
    }

    private async Task HandlePromptGeneration(MathInputComponent.ComicGenerationRequest request)
    {
        var startTime = DateTime.Now;
        
        try
        {
            // Log user action
            await JSRuntime.InvokeVoidAsync("logUserInput", "prompt_generation_request", request.MathConcept.Topic, null);
            await JSRuntime.InvokeVoidAsync("logInfo", "Starting prompt generation", new {
                mathConcept = request.MathConcept.Topic,
                ageGroup = request.Options.AgeGroup.ToString(),
                panelCount = request.Options.PanelCount,
                visualStyle = request.Options.VisualStyle.ToString(),
                language = request.Options.Language.ToString(),
                enablePinyin = request.Options.EnablePinyin
            }, "PROMPT_GENERATION");

            isGeneratingPrompt = true;
            StateHasChanged();

            await ShowNotification("Starting prompt generation...");

            // 第一步：生成提示词
            var requestData = new
            {
                MathConcept = request.MathConcept.Topic,
                Options = request.Options
            };

            // Log API request
            await JSRuntime.InvokeVoidAsync("logApiRequest", "POST", "/api/comic/generate-prompt", requestData, null);
            await ShowNotification($"Sending request: concept={request.MathConcept.Topic}");

            var response = await Http.PostAsJsonAsync("/api/comic/generate-prompt", requestData);
            var duration = (DateTime.Now - startTime).TotalMilliseconds;

            await ShowNotification($"Received response: status={response.StatusCode}");

            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadAsStringAsync();
                await ShowNotification($"Response content length: {responseContent.Length}");

                // 解析包装的响应格式
                var wrappedResponse = await response.Content.ReadFromJsonAsync<ApiResponse<PromptGenerationResponse>>();
                
                // Log API response
                await JSRuntime.InvokeVoidAsync("logApiResponse", "POST", "/api/comic/generate-prompt", 
                    (int)response.StatusCode, wrappedResponse, duration);
                
                if (wrappedResponse?.Data != null)
                {
                    currentPromptResponse = wrappedResponse.Data;
                    currentStep = GenerationStep.PromptEdit;
                    
                    // Log state change
                    await JSRuntime.InvokeVoidAsync("logStateChange", "Index", "Input", "PromptEdit");
                    await JSRuntime.InvokeVoidAsync("logInfo", "Prompt generation successful", new {
                        promptId = currentPromptResponse.Id,
                        duration = $"{duration}ms"
                    }, "PROMPT_GENERATION");
                    
                    await ShowNotification($"Prompt generation successful! ID: {currentPromptResponse.Id}");
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("logError", "Prompt response parsing failed", "Response data is null", "PROMPT_GENERATION");
                    await ShowNotification("Prompt response parsing failed");
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                await JSRuntime.InvokeVoidAsync("logApiError", "POST", "/api/comic/generate-prompt", 
                    $"HTTP {response.StatusCode}: {errorContent}", requestData);
                await ShowNotification($"Prompt generation failed: {response.StatusCode} - {errorContent}");
            }
        }
        catch (Exception ex)
        {
            var duration = (DateTime.Now - startTime).TotalMilliseconds;
            await JSRuntime.InvokeVoidAsync("logError", "Error during prompt generation", ex.Message, "PROMPT_GENERATION");
            await JSRuntime.InvokeVoidAsync("logPerformance", "prompt_generation_error", duration, new { error = ex.Message });
            await ShowNotification($"Error during prompt generation: {ex.Message}");
        }
        finally
        {
            isGeneratingPrompt = false;
            StateHasChanged();
            
            var totalDuration = (DateTime.Now - startTime).TotalMilliseconds;
            await JSRuntime.InvokeVoidAsync("logPerformance", "prompt_generation_total", totalDuration, new { 
                success = currentPromptResponse != null 
            });
        }
    }

    private async Task HandleComicGeneration(ComicImageGenerationRequest request)
    {
        var startTime = DateTime.Now;
        
        try
        {
            // Log comic generation start
            await JSRuntime.InvokeVoidAsync("logComicGeneration", "comic_generation", "started", new {
                promptId = request.PromptId,
                hasEditedPrompt = !string.IsNullOrEmpty(request.EditedPrompt)
            });

            isGeneratingComic = true;
            StateHasChanged();

            // Log API request
            await JSRuntime.InvokeVoidAsync("logApiRequest", "POST", "/api/comic/generate-from-prompt", request, null);

            // 第二步：根据提示词生成漫画
            var response = await Http.PostAsJsonAsync("/api/comic/generate-from-prompt", request);
            var duration = (DateTime.Now - startTime).TotalMilliseconds;

            if (response.IsSuccessStatusCode)
            {
                var wrappedResponse = await response.Content.ReadFromJsonAsync<ApiResponse<MultiPanelComic>>();
                
                // Log API response
                await JSRuntime.InvokeVoidAsync("logApiResponse", "POST", "/api/comic/generate-from-prompt", 
                    (int)response.StatusCode, wrappedResponse, duration);
                
                if (wrappedResponse?.Data != null)
                {
                    currentComic = wrappedResponse.Data;
                    
                    // Log successful comic generation
                    await JSRuntime.InvokeVoidAsync("logComicGeneration", "comic_generation", "completed", new {
                        comicId = currentComic.Id,
                        title = currentComic.Title,
                        panelCount = currentComic.Panels.Count,
                        duration = $"{duration}ms"
                    });
                    
                    await ShowNotification("Comic generation successful!");
                    await LoadComicHistory(); // 刷新历史记录
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("logError", "Comic response parsing failed", "Response data is null", "COMIC_GENERATION");
                    await ShowNotification("Comic response parsing failed");
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                await JSRuntime.InvokeVoidAsync("logApiError", "POST", "/api/comic/generate-from-prompt", 
                    $"HTTP {response.StatusCode}: {errorContent}", request);
                await ShowNotification($"Comic generation failed: {errorContent}");
            }
        }
        catch (Exception ex)
        {
            var duration = (DateTime.Now - startTime).TotalMilliseconds;
            await JSRuntime.InvokeVoidAsync("logError", "Error during comic generation", ex.Message, "COMIC_GENERATION");
            await JSRuntime.InvokeVoidAsync("logPerformance", "comic_generation_error", duration, new { error = ex.Message });
            await ShowNotification($"Error during comic generation: {ex.Message}");
        }
        finally
        {
            isGeneratingComic = false;
            StateHasChanged();
            
            var totalDuration = (DateTime.Now - startTime).TotalMilliseconds;
            await JSRuntime.InvokeVoidAsync("logPerformance", "comic_generation_total", totalDuration, new { 
                success = currentComic != null 
            });
        }
    }

    private async Task HandleGoBackToInput()
    {
        currentStep = GenerationStep.Input;
        currentPromptResponse = null;
        StateHasChanged();
    }

    private async Task HandleSaveComic(MultiPanelComic comic)
    {
        try
        {
            // 调用API保存漫画
            var response = await Http.PostAsJsonAsync("/api/comic/save", comic);
            
            if (response.IsSuccessStatusCode)
            {
                await ShowNotification("漫画保存成功！");
                await LoadComicHistory(); // 刷新历史记录
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                await ShowNotification($"保存失败：{errorContent}");
            }
        }
        catch (Exception ex)
        {
            await ShowNotification($"保存失败：{ex.Message}");
        }
    }

    private async Task HandleShareComic(MultiPanelComic comic)
    {
        try
        {
            // 实现分享功能 - 这里可以复制链接到剪贴板
            var shareUrl = $"{NavigationManager.BaseUri}comic/{comic.Id}";
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", shareUrl);
            await ShowNotification("分享链接已复制到剪贴板");
        }
        catch (Exception ex)
        {
            await ShowNotification($"分享失败：{ex.Message}");
        }
    }

    private async Task HandleShareComic(ComicMetadata comic)
    {
        try
        {
            // 从历史记录分享
            var shareUrl = $"{NavigationManager.BaseUri}comic/{comic.MathConcept}";
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", shareUrl);
            await ShowNotification("分享链接已复制到剪贴板");
        }
        catch (Exception ex)
        {
            await ShowNotification($"分享失败：{ex.Message}");
        }
    }

    private async Task HandleExportComic((MultiPanelComic Comic, ComicDisplayComponent.ExportFormat Format) exportRequest)
    {
        try
        {
            var response = await Http.GetAsync($"/api/comic/{exportRequest.Comic.Id}/export?format={exportRequest.Format}");
            
            if (response.IsSuccessStatusCode)
            {
                var content = await response.Content.ReadAsByteArrayAsync();
                var fileName = $"comic_{exportRequest.Comic.Id}.{exportRequest.Format.ToString().ToLower()}";
                
                // 触发文件下载
                await JSRuntime.InvokeVoidAsync("downloadFile", fileName, Convert.ToBase64String(content));
                await ShowNotification("导出成功");
            }
            else
            {
                await ShowNotification("导出失败");
            }
        }
        catch (Exception ex)
        {
            await ShowNotification($"导出失败：{ex.Message}");
        }
    }

    private async Task LoadComicHistory()
    {
        var startTime = DateTime.Now;
        
        try
        {
            await JSRuntime.InvokeVoidAsync("logInfo", "Loading comic history", null, "HISTORY_LOAD");
            
            isLoadingHistory = true;
            StateHasChanged();

            // Log API request
            await JSRuntime.InvokeVoidAsync("logApiRequest", "GET", "/api/comic", null, null);

            var response = await Http.GetAsync("/api/comic");
            var duration = (DateTime.Now - startTime).TotalMilliseconds;
            
            if (response.IsSuccessStatusCode)
            {
                var wrappedResponse = await response.Content.ReadFromJsonAsync<ApiResponse<List<ComicMetadata>>>();
                comicHistory = wrappedResponse?.Data ?? new();
                
                // Log successful load
                await JSRuntime.InvokeVoidAsync("logApiResponse", "GET", "/api/comic", 
                    (int)response.StatusCode, wrappedResponse, duration);
                await JSRuntime.InvokeVoidAsync("logInfo", "Comic history loaded successfully", new {
                    count = comicHistory.Count,
                    duration = $"{duration}ms"
                }, "HISTORY_LOAD");
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("logApiError", "GET", "/api/comic", 
                    $"HTTP {response.StatusCode}", null);
            }
        }
        catch (Exception ex)
        {
            var duration = (DateTime.Now - startTime).TotalMilliseconds;
            await JSRuntime.InvokeVoidAsync("logError", "Failed to load comic history", ex.Message, "HISTORY_LOAD");
            await JSRuntime.InvokeVoidAsync("logPerformance", "history_load_error", duration, new { error = ex.Message });
            await ShowNotification($"Failed to load history: {ex.Message}");
        }
        finally
        {
            isLoadingHistory = false;
            StateHasChanged();
            
            var totalDuration = (DateTime.Now - startTime).TotalMilliseconds;
            await JSRuntime.InvokeVoidAsync("logPerformance", "history_load_total", totalDuration, new { 
                success = comicHistory.Count > 0 
            });
        }
    }

    private async Task HandleViewComic(ComicMetadata comic)
    {
        try
        {
            // 加载完整的漫画数据
            var response = await Http.GetAsync($"/api/comic/{comic.MathConcept}");
            if (response.IsSuccessStatusCode)
            {
                var wrappedResponse = await response.Content.ReadFromJsonAsync<ApiResponse<MultiPanelComic>>();
                if (wrappedResponse?.Data != null)
                {
                    currentComic = wrappedResponse.Data;
                    StateHasChanged();
                }
            }
        }
        catch (Exception ex)
        {
            await ShowNotification($"加载漫画失败：{ex.Message}");
        }
    }

    private async Task HandleDeleteComic(ComicMetadata comic)
    {
        try
        {
            var response = await Http.DeleteAsync($"/api/comic/{comic.MathConcept}");
            if (response.IsSuccessStatusCode)
            {
                await ShowNotification("漫画已删除");
                await LoadComicHistory(); // 刷新历史记录
            }
            else
            {
                await ShowNotification("删除失败");
            }
        }
        catch (Exception ex)
        {
            await ShowNotification($"删除失败：{ex.Message}");
        }
    }

    private async Task ShowNotification(string message)
    {
        notificationMessage = message;
        StateHasChanged();
        
        // Log notification
        try
        {
            await JSRuntime.InvokeVoidAsync("logInfo", "Showing notification", new { 
                message = message,
                timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")
            }, "NOTIFICATION");
            
            await JSRuntime.InvokeVoidAsync("showToast", "notificationToast");
        }
        catch (InvalidOperationException)
        {
            // 在预渲染阶段忽略JavaScript调用错误
        }
    }
}

<script>
    window.showToast = (toastId) => {
        const toastElement = document.getElementById(toastId);
        if (toastElement) {
            // 简单的显示/隐藏实现，不依赖Bootstrap JavaScript
            toastElement.style.display = 'block';
            toastElement.classList.add('show');
            
            // 3秒后自动隐藏
            setTimeout(() => {
                toastElement.style.display = 'none';
                toastElement.classList.remove('show');
            }, 3000);
        }
    };

    window.downloadFile = (fileName, base64Content) => {
        const link = document.createElement('a');
        link.href = 'data:application/octet-stream;base64,' + base64Content;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };
</script>