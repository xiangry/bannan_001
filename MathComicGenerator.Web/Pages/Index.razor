@page "/"
@using MathComicGenerator.Shared.Models
@using MathComicGenerator.Web.Components
@using Microsoft.JSInterop
@inject HttpClient Http
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inherits OptimizedComponentBase

<PageTitle>数学漫画生成器</PageTitle>

<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="text-center mb-4">
                <h1 class="display-4 text-primary">
                    <i class="fas fa-magic me-3"></i>
                    数学漫画生成器
                </h1>
                <p class="lead text-muted">让数学学习变得生动有趣</p>
            </div>
        </div>
    </div>

    <div class="row">
        @if (currentStep == GenerationStep.Input)
        {
            <!-- 输入区域 -->
            <div class="col-lg-4 mb-4">
                <MathInputComponent OnSubmit="HandlePromptGeneration" IsGenerating="isGeneratingPrompt" />
            </div>

            <!-- 漫画显示区域 -->
            <div class="col-lg-8 mb-4">
                <ComicDisplayComponent Comic="currentComic" 
                                     IsLoading="isGeneratingComic"
                                     OnSave="HandleSaveComic"
                                     OnShare="HandleShareComic"
                                     OnExport="HandleExportComic" />
            </div>
        }
        else if (currentStep == GenerationStep.PromptEdit)
        {
            <!-- 提示词编辑区域 -->
            <div class="col-lg-6 mb-4">
                <PromptEditorComponent PromptResponse="currentPromptResponse"
                                     IsGenerating="isGeneratingComic"
                                     OnGenerateComic="HandleComicGeneration"
                                     OnGoBack="HandleGoBackToInput" />
            </div>

            <!-- 漫画显示区域 -->
            <div class="col-lg-6 mb-4">
                <ComicDisplayComponent Comic="currentComic" 
                                     IsLoading="isGeneratingComic"
                                     OnSave="HandleSaveComic"
                                     OnShare="HandleShareComic"
                                     OnExport="HandleExportComic" />
            </div>
        }
    </div>

    <div class="row">
        <!-- 历史记录区域 -->
        <div class="col-12">
            <HistoryComponent ComicHistory="comicHistory"
                            IsLoading="isLoadingHistory"
                            OnRefresh="LoadComicHistory"
                            OnView="HandleViewComic"
                            OnShare="HandleShareComic"
                            OnDelete="HandleDeleteComic" />
        </div>
    </div>
</div>

<!-- 通知Toast -->
<div class="toast-container position-fixed bottom-0 end-0 p-3">
    <div id="notificationToast" class="toast" role="alert">
        <div class="toast-header">
            <i class="fas fa-info-circle text-primary me-2"></i>
            <strong class="me-auto">通知</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast"></button>
        </div>
        <div class="toast-body">
            @notificationMessage
        </div>
    </div>
</div>

@code {
    private MultiPanelComic? currentComic;
    private PromptGenerationResponse? currentPromptResponse;
    private List<ComicMetadata> comicHistory = new();
    private GenerationStep currentStep = GenerationStep.Input;
    private bool isGeneratingPrompt = false;
    private bool isGeneratingComic = false;
    private bool isLoadingHistory = false;
    private string notificationMessage = string.Empty;

    public enum GenerationStep
    {
        Input,
        PromptEdit
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        
        // 非阻塞的组件初始化日志
        _ = LogUserActionAsync("ComponentInitializing", new { 
            step = currentStep.ToString(),
            timestamp = DateTime.UtcNow
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        
        if (firstRender)
        {
            try
            {
                await LoadComicHistory();
            }
            catch (Exception ex)
            {
                await LogErrorAsync("Error in OnAfterRenderAsync", ex);
            }
        }
    }

    private async Task HandlePromptGeneration(MathInputComponent.ComicGenerationRequest request)
    {
        await ExecuteWithPerformanceTrackingAsync("PromptGeneration", async () =>
        {
            try
            {
                // 非阻塞的用户操作日志
                _ = LogUserActionAsync("PromptGenerationRequest", new {
                    mathConcept = request.MathConcept.Topic,
                    ageGroup = request.Options.AgeGroup.ToString(),
                    panelCount = request.Options.PanelCount,
                    visualStyle = request.Options.VisualStyle.ToString(),
                    language = request.Options.Language.ToString(),
                    enablePinyin = request.Options.EnablePinyin
                });

                isGeneratingPrompt = true;
                SafeStateHasChanged();

                await ShowNotificationAsync("正在生成提示词...");

                // 第一步：生成提示词
                var requestData = new
                {
                    MathConcept = request.MathConcept.Topic,
                    Options = request.Options
                };

                // 非阻塞的API请求日志
                _ = LogApiRequestAsync("POST", "/api/comic/generate-prompt", requestData);

                var response = await Http.PostAsJsonAsync("/api/comic/generate-prompt", requestData);

                var apiElapsed = response.Headers.Contains("ProcessingTime") ? response.Headers.GetValues("ProcessingTime").FirstOrDefault() : null;

                if (response.IsSuccessStatusCode)
                {
                    // 解析包装的响应格式
                    MathComicGenerator.Shared.Models.ApiResponse<PromptGenerationResponse>? wrappedResponse = null;
                    try
                    {
                        wrappedResponse = await response.Content.ReadFromJsonAsync<MathComicGenerator.Shared.Models.ApiResponse<PromptGenerationResponse>>();
                    }
                    catch (Exception parseEx)
                    {
                        var raw = await response.Content.ReadAsStringAsync();
                        await LogErrorAsync("Prompt response JSON parse failed", parseEx, raw);
                        await ShowNotificationAsync($"提示词响应解析失败: {parseEx.Message}");
                    }

                    // 非阻塞的API响应日志
                    _ = LogApiResponseAsync("POST", "/api/comic/generate-prompt", (int)response.StatusCode, wrappedResponse);

                    if (wrappedResponse?.Data != null)
                    {
                        currentPromptResponse = wrappedResponse.Data;
                        currentStep = GenerationStep.PromptEdit;

                        // 非阻塞的状态变化日志
                        _ = LogStateChangeAsync("Input", "PromptEdit", new { promptId = currentPromptResponse.Id });

                        var notifyMsg = $"提示词生成成功！ID: {currentPromptResponse.Id}";
                        if (!string.IsNullOrEmpty(wrappedResponse.ProcessingTime)) notifyMsg += $" (后端耗时: {wrappedResponse.ProcessingTime})";

                        await ShowNotificationAsync(notifyMsg);
                    }
                    else
                    {
                        await LogErrorAsync("Prompt response parsing failed", null, "Response data is null or parsing failed");
                        var errorBody = await response.Content.ReadAsStringAsync();
                        await ShowNotificationAsync($"提示词响应解析失败: {errorBody}");
                    }
                }
                else
                {
                    var errorContent = await response.Content.ReadAsStringAsync();
                    await LogErrorAsync($"Prompt generation failed: {response.StatusCode}", null, errorContent);
                    await ShowNotificationAsync($"提示词生成失败: {response.StatusCode} - {errorContent}");
                }
            }
            catch (Exception ex)
            {
                await LogErrorAsync("Error during prompt generation", ex);
                await ShowNotificationAsync($"生成提示词时发生错误: {ex.Message}");
            }
            finally
            {
                isGeneratingPrompt = false;
                SafeStateHasChanged();
            }
        });
    }

    private async Task HandleComicGeneration(ComicImageGenerationRequest request)
    {
        await ExecuteWithPerformanceTrackingAsync("ComicGeneration", async () =>
        {
            try
            {
                // 非阻塞的漫画生成开始日志
                _ = LogUserActionAsync("ComicGenerationStarted", new {
                    promptId = request.PromptId,
                    hasEditedPrompt = !string.IsNullOrEmpty(request.EditedPrompt)
                });

                isGeneratingComic = true;
                SafeStateHasChanged();

                // 非阻塞的API请求日志
                _ = LogApiRequestAsync("POST", "/api/comic/generate-from-prompt", request);

                // 第二步：根据提示词生成漫画
                var response = await Http.PostAsJsonAsync("/api/comic/generate-from-prompt", request);

                if (response.IsSuccessStatusCode)
                {
                    var wrappedResponse = await response.Content.ReadFromJsonAsync<ApiResponse<MultiPanelComic>>();
                    
                    // 非阻塞的API响应日志
                    _ = LogApiResponseAsync("POST", "/api/comic/generate-from-prompt", (int)response.StatusCode, wrappedResponse);
                    
                    if (wrappedResponse?.Data != null)
                    {
                        currentComic = wrappedResponse.Data;
                        
                        // 非阻塞的成功日志
                        _ = LogUserActionAsync("ComicGenerationCompleted", new {
                            comicId = currentComic.Id,
                            title = currentComic.Title,
                            panelCount = currentComic.Panels.Count
                        });
                        
                        await ShowNotificationAsync("漫画生成成功！");
                        await LoadComicHistory(); // 刷新历史记录
                    }
                    else
                    {
                        await LogErrorAsync("Comic response parsing failed", null, "Response data is null");
                        await ShowNotificationAsync("漫画响应解析失败");
                    }
                }
                else
                {
                    var errorContent = await response.Content.ReadAsStringAsync();
                    await LogErrorAsync($"Comic generation failed: {response.StatusCode}", null, errorContent);
                    await ShowNotificationAsync($"漫画生成失败: {errorContent}");
                }
            }
            catch (Exception ex)
            {
                await LogErrorAsync("Error during comic generation", ex);
                await ShowNotificationAsync($"生成漫画时发生错误: {ex.Message}");
            }
            finally
            {
                isGeneratingComic = false;
                SafeStateHasChanged();
            }
        });
    }

    private async Task HandleGoBackToInput()
    {
        currentStep = GenerationStep.Input;
        currentPromptResponse = null;
        StateHasChanged();
    }

    private async Task HandleSaveComic(MultiPanelComic comic)
    {
        try
        {
            // 调用API保存漫画
            var response = await Http.PostAsJsonAsync("/api/comic/save", comic);
            
            if (response.IsSuccessStatusCode)
            {
                await ShowNotification("漫画保存成功！");
                await LoadComicHistory(); // 刷新历史记录
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                await ShowNotification($"保存失败：{errorContent}");
            }
        }
        catch (Exception ex)
        {
            await ShowNotification($"保存失败：{ex.Message}");
        }
    }

    private async Task HandleShareComic(MultiPanelComic comic)
    {
        try
        {
            // 实现分享功能 - 这里可以复制链接到剪贴板
            var shareUrl = $"{NavigationManager.BaseUri}comic/{comic.Id}";
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", shareUrl);
            await ShowNotification("分享链接已复制到剪贴板");
        }
        catch (Exception ex)
        {
            await ShowNotification($"分享失败：{ex.Message}");
        }
    }

    private async Task HandleShareComic(ComicMetadata comic)
    {
        try
        {
            // 从历史记录分享
            var shareUrl = $"{NavigationManager.BaseUri}comic/{comic.MathConcept}";
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", shareUrl);
            await ShowNotification("分享链接已复制到剪贴板");
        }
        catch (Exception ex)
        {
            await ShowNotification($"分享失败：{ex.Message}");
        }
    }

    private async Task HandleExportComic((MultiPanelComic Comic, ComicDisplayComponent.ExportFormat Format) exportRequest)
    {
        try
        {
            var response = await Http.GetAsync($"/api/comic/{exportRequest.Comic.Id}/export?format={exportRequest.Format}");
            
            if (response.IsSuccessStatusCode)
            {
                var content = await response.Content.ReadAsByteArrayAsync();
                var fileName = $"comic_{exportRequest.Comic.Id}.{exportRequest.Format.ToString().ToLower()}";
                
                // 触发文件下载
                await JSRuntime.InvokeVoidAsync("downloadFile", fileName, Convert.ToBase64String(content));
                await ShowNotification("导出成功");
            }
            else
            {
                await ShowNotification("导出失败");
            }
        }
        catch (Exception ex)
        {
            await ShowNotification($"导出失败：{ex.Message}");
        }
    }

    private async Task LoadComicHistory()
    {
        await ExecuteWithPerformanceTrackingAsync("LoadComicHistory", async () =>
        {
            try
            {
                isLoadingHistory = true;
                SafeStateHasChanged();

                // 非阻塞的API请求日志
                _ = LogApiRequestAsync("GET", "/api/comic");

                var response = await Http.GetAsync("/api/comic");
                
                if (response.IsSuccessStatusCode)
                {
                    var wrappedResponse = await response.Content.ReadFromJsonAsync<ApiResponse<List<ComicMetadata>>>();
                    comicHistory = wrappedResponse?.Data ?? new();
                    
                    // 非阻塞的成功日志
                    _ = LogApiResponseAsync("GET", "/api/comic", (int)response.StatusCode, wrappedResponse);
                    _ = LogUserActionAsync("ComicHistoryLoaded", new { count = comicHistory.Count });
                }
                else
                {
                    await LogErrorAsync($"Failed to load comic history: {response.StatusCode}");
                }
            }
            catch (Exception ex)
            {
                await LogErrorAsync("Failed to load comic history", ex);
                await ShowNotificationAsync($"加载历史记录失败: {ex.Message}");
            }
            finally
            {
                isLoadingHistory = false;
                SafeStateHasChanged();
            }
        });
    }

    private async Task HandleViewComic(ComicMetadata comic)
    {
        try
        {
            // 加载完整的漫画数据
            var response = await Http.GetAsync($"/api/comic/{comic.MathConcept}");
            if (response.IsSuccessStatusCode)
            {
                var wrappedResponse = await response.Content.ReadFromJsonAsync<ApiResponse<MultiPanelComic>>();
                if (wrappedResponse?.Data != null)
                {
                    currentComic = wrappedResponse.Data;
                    StateHasChanged();
                }
            }
        }
        catch (Exception ex)
        {
            await ShowNotification($"加载漫画失败：{ex.Message}");
        }
    }

    private async Task HandleDeleteComic(ComicMetadata comic)
    {
        try
        {
            var response = await Http.DeleteAsync($"/api/comic/{comic.MathConcept}");
            if (response.IsSuccessStatusCode)
            {
                await ShowNotification("漫画已删除");
                await LoadComicHistory(); // 刷新历史记录
            }
            else
            {
                await ShowNotification("删除失败");
            }
        }
        catch (Exception ex)
        {
            await ShowNotification($"删除失败：{ex.Message}");
        }
    }

    private async Task ShowNotification(string message)
    {
        notificationMessage = message;
        SafeStateHasChanged();
        
        // 非阻塞的通知日志
        _ = LogUserActionAsync("ShowNotification", new { message });
        
        // 简化的通知显示，避免JavaScript调用
        // 实际的Toast显示可以通过CSS动画或其他方式实现
    }
}

<script>
    window.showToast = (toastId) => {
        const toastElement = document.getElementById(toastId);
        if (toastElement) {
            // 简单的显示/隐藏实现，不依赖Bootstrap JavaScript
            toastElement.style.display = 'block';
            toastElement.classList.add('show');
            
            // 3秒后自动隐藏
            setTimeout(() => {
                toastElement.style.display = 'none';
                toastElement.classList.remove('show');
            }, 3000);
        }
    };

    window.downloadFile = (fileName, base64Content) => {
        const link = document.createElement('a');
        link.href = 'data:application/octet-stream;base64,' + base64Content;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };
</script>
